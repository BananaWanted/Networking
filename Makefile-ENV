SYSTEM_NAME = $(shell uname -s)
WITH_MINIKUBE_DOCKER_ENV = eval $$\(minikube docker-env)

.PHONY: env_helm env_kubectl env_minikube

env_helm:
ifeq ($(SYSTEM_NAME), Darwin)
	brew install kubernetes-helm
else
	set -o pipefail; \
	curl -LO https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get | bash
endif

env_kubectl:
ifeq ($(SYSTEM_NAME), Darwin)
	brew install kubernetes-cli
else
	curl -LO https://storage.googleapis.com/kubernetes-release/release/$$\(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
	chmod +x ./kubectl
	sudo mv ./kubectl /usr/local/bin/kubectl
endif

env_minikube: env_kubectl
	# docker should be available and working
	docker images > /dev/null
ifeq ($(SYSTEM_NAME), Darwin)
	brew cask install minikube
	minikube start --alsologtostderr --vm-driver hyperkit
else
	curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.28.1/minikube-linux-amd64
	chmod +x minikube
	sudo mv minikube /usr/local/bin/
	sudo minikube start --alsologtostderr --vm-driver=none
	minikube update-context
endif
	# waiting for booting
	JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; \
	until kubectl get nodes -o jsonpath="$$JSONPATH" 2>&1 | grep -q "Ready=True"; do \
		sleep 1; \
	done
	minikube addons enable kube-dns
	minikube addons enable ingress
